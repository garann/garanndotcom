<html><head><meta charset="utf-8"><title>totes profesh: jsPerf vs. templates</title><link rel="stylesheet" href="../../../garanndotcom.css" /></head><body><div class="header"><h2><a href="../index.html">garann means &gt; totes profesh</a></h2>a defunct web development blog</div><h1>jsPerf vs. templates</h1><div class="meta">Thu, 16 Sep 2010 23:31:38 +0000</div><div class="content"><p>Yesterday I saw a <a href="http://twitter.com/segdeha/status/24589265695">tweet</a> about a jsPerf test case comparing templates, which got me curious about how various types of JS templates stack up - to each other and to the other methods. I took a look through the <a href="http://jsperf.com/browse">public test cases</a> on <a href="http://jsperf.com/">jsPerf</a> and found several more people answering that question in various ways, which yielded some interesting info:</p>

<ul>
<li><a href="http://jsperf.com/javascript-templating">JavaScript Templating</a> - the test case from the tweet, comparing micro-templating and a custom engine</li>
<li><a href="http://jsperf.com/dom-vs-innerhtml-based-templating/8">DOM vs innerHTML based Templating</a> - compares seven different template engines</li>
<li><a href="http://jsperf.com/ntpl-vs-mustache">nTPL vs Mustache</a> - yes, that</li>
<li><a href="http://jsperf.com/precompiled-templates/2">Precompiled templates</a> - precompiled version of micro-templating against uncompiled ones</li>
<li><a href="http://jsperf.com/template-vs-concatanation">Template vs concatanation</a> - what it says</li>
</ul>

<p>After looking at these, (probably for no good reason) I was curious if anything would change if the template were more complex and there were more data - the test cases above all produce fairly simple markup. To make a long story short, no, there's no difference I could see (but <a href="http://jsperf.com/complex-template-vs-concat/4">don't take my word for it</a>). That's not really so surprising since it's all just string manipulation. The more complex templating engines seem to take longer, in general. The ones with simpler vocabularies are pretty fast. But performance-wise? Smaller is still better.</p>

<b>That's actually a good thing!</b>

<p>Ok, not <i>good</i>, but not terrible. One thing I noticed as I tweaked various things was that the relationship between the speed of concatenation and speed of the template seemed to stay the same. I was concerned that with more data, there might be more problems. When I added more data, though, both methods slowed by around the same percentage. For reference, templates seem to take about 150% the time to process that concatenation needs, assuming you're considering really unperformant concatenation, which I was (cheating has been removed in the latest revisions).</p>
<p>So there's a performance sacrifice in using templates over doing all the concatenation yourself. This is not really a shocker, because when you do it manually Javascript doesn't have to parse the markup bits of the final product - it's just dumb text. In my initial curiosity, I didn't think things through fully and realize that anything the concatenation approach is going to have to do, the template approach will eventually have to do as well. Also not surprising, then, that the template engines that come out on top in the second bullet point above are those that appear to switch back and forth between pure JS and dumb text, basically just expanded versions of concatenation.</p>
<p>Referring back to the shorter examples people had posted, I doubt you'd want a template in many of those scenarios if performance was at all a factor. In the example I was using, though, I would still choose to take the performance hit because of the readability advantage. It's possible to organize concatenation so it can be worked with more easily (which I tried to do, cause it was beating the pants off templates anyway and putting it all on one line would have been cruel), but it's still less maintainable than markup is going to be. You have to worry about escaping quotes or apostrophes, you can't indent accurately, and there's a disincentive to separate elements that might be part of different concepts on the page.</p>
<p>One thing that's still bugging me is how to deal with nested templates. I added a test case trying to split out the template for an array of objects under the parent, and it didn't do a whole lot better than a for loop within a single template. I'm wondering how various template engines handle that. Maybe someone will eventually post that test case. Maybe me! But not tonight.</p>

<b>..Oh yeah, speaking of templates</b>
<p>In case you're one of the five people in the world I haven't told, I'm going to be speaking about that very subject at the <a href="http://events.jquery.org/2010/boston/">Boston jQuery Conference</a> coming up in October. I'm pretty excited about it. Hey, look at that! There are still tickets available....</p></div></body></html>